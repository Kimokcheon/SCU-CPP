# Assignment 2 
[toc]



## 概述

​	第二次作业。

​	这次就不是全部截图了(

​	建议学长下次布置作业下发代码包(复制带行号好痛苦)

​	最后一题较冗杂，纯折磨人。



## Makefile & Cmake

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230308210347708.png" alt="image-20230308210347708" style="zoom: 33%;" />

基于最简单的cmake打包方式，文件夹内容如下：

​	question2

​	----build

​	----CMakelists.txt

​	----main.cpp

​	----stuinfo.cpp

​	----stuinfo.h

​	

把头文件独立出来的打包方式：

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230310171630876.png" alt="image-20230310171630876" style="zoom: 33%;" />

文件内容：

​	question2

​	---build

​	---src

​	------main.cpp

​	------stuinfo.cpp

​	---include

​	-------stuinfo.h



**具体代码见：question2**





## Types

### static 用法和作用

​	用 static 修饰局部变量时，被修饰的变量变为静态变量，在main函数之前初始化，在程序退出时销毁。

​	用 static 修饰全局变量，只能被static修饰的全局变量只能被该包含该定义的文件访问

​	static 修饰函数使得函数只能在包含该函数定义的文件中被调用。

​	static 修饰成员变量时，该变量不属于哪一个具体的对象，而属于整个类，当某个对象修改该变量时，也会影响到其他对象。静态成员变量的内存分配在（类外）初始化时分配。static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。

​	static 修饰成员函数时，静态成员函数只能访问静态成员。静态成员函数没有 this 指针，不指向哪个对象，无法访问对象的成员变量。

### 隐式转换

​	隐式转换是 C++ 内部默认的强制类型转换方式，当一个表达包含若干个不同类型的变量时， C++ 会自动对其进行类型转换。例如，在对变量赋值时，若等号两边的数据类型不同，需要把右边表达式的类型转换为左边变量的类型；在运算过程中，不同类型的数据需要转换为同一类；在函数调用中，传入函数的变量会自动转换为函数定义的类型。一般来说，隐式转换的转换规则如下：转换按数据长度增加的方向进行，以保证数据精度不降低；在条件判断中，非布尔类型自动转换为布尔类型；当有符号类型转换为无符号类型时，其值可能发生变化。

​	关于隐式转换，我们在写表达式时尽可能使用显示转换来规避这个问题。或者用宏 EXPLICIT 关闭函数的隐式转换。在写函数时使用模板函数替代。

### 程序解释

#### 程序1

​	运行结果如下：

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230310181134406.png" alt="image-20230310181134406" style="zoom: 50%;" />

​	对于 sum ，由于 num1 + num2 爆 int 了，答案自溢出了。

​	对于 fsum , 由于fsum,f1,f2都是 float，f1在存1234567890时丢失了精度，在进行fsum=f1+f2 时也丢失了精度，fsum 在当前精度下和 f1 是相同的。

​	由于计算机存储小数是二进制存储，在存0.1时是丢失了精度的，而进行加法会加大这种精度误差，从而导致最后不等于1，而乘法精度丢失更小。而在cout输出里是会自动四舍五入的。



#### 程序2

​	运行结果如下：

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230310183217186.png" alt="image-20230310183217186" style="zoom:50%;" />

​	cout输出会自动四舍五入，所以输出f2会是1.000000，而他们在二进制存储上是不一样的。



#### 程序3

​	运行结果如下：

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230310183459291.png" alt="image-20230310183459291" style="zoom:50%;" />

​	对于a，由于a是整数，后面是浮点运算，会先进行浮点运算然后自动丢弃小数点后的值。

​	对于b，由于后面有强制类型转换，所以实际上就是19+21。

​	对于c，整数除法是向下取整。

​	对于d，由于运算式子存在浮点数，运算过程的值会自动转换为浮点数。

​	对于 0/0，这会run time error，也有可能会输出 nan 吧。



## Structs

### 结构体对齐

​	alignas定义的对齐大小大于等于结构体内所有成员的大小时，可以生效，反之不能。

### Exercise

main.cpp:

​	<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230310195349348.png" alt="image-20230310195349348" style="zoom:50%;" />

运行结果：

​	![image-20230310195413421](C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230310195413421.png)

​	(看起来第四个应该是(0,0))



**具体实现见：question4**



## C++ 动态内存申请

### 内存分区

​	(1)static定义的全局变量应该在全局/静态存储区

​	(2)auto变量在栈区

​	(3)字符数组在栈

​	(4)字符指针在栈，字符常量在静态存储区

​	(5)malloc申请的空间在堆，p1变量本身在栈

​	(6)new申请的空间在自由存储区，a本身在栈

### 问答题

​	1. new 和 malloc 的区别

​		new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。

​		new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配；而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型

​		new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL

​		使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸

​		使用new[]分配的内存必须使用delete[]进行释放

​		operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new

​	2. delete p、delete[ ] p、allocator 都有什么作用?

​		delete p会调用一次析构函数，而delete[] p会调用每个成员的析构函数，对于普通数据类型而言，他们作用的效果是一样的；如果数组类型是自定义类，那么new[]只能用delete[]来对应，new和delete对应；

​		allocator类是C++的一个模板，它提供类型化的内存分配以及对象的分配和撤销。

​	3.malloc 申请的存储空间能用 delete 释放吗？

​		可以的。new 和delete会自动进行类型检查和大小。

​	4. malloc 与 free 的实现原理?

​		malloc采用的是内存池的实现方式，先申请一大块内存，然后将内存分成不同大小的内存块，然后用户申请内存时，直接从内存池中选择一块相近的内存块即可。具体而言，在堆中申请空间会遍历空闲链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。

​		free函数将用户释放的内存块连接到空闲链表上。

### Exercise

​	主函数：

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313210532966.png" alt="image-20230313210532966" style="zoom: 33%;" />

​	运行结果如下：

​		<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313210512826.png" alt="image-20230313210512826" style="zoom:33%;" />



**具体代码见：question5**



## Debug 和 Release

### 如何判断动态申请越界（C 方式，注意源程序后缀为.c）

VS2022 的 x86/Debug，Release 模式：

结果1

​	Release

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313220526415.png" alt="image-20230313220526415" style="zoom:33%;" />

​	Debug

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313220246784.png" alt="image-20230313220246784" style="zoom:33%;" />



结果2

​	Release

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313215332114.png" alt="image-20230313215332114" style="zoom:33%;" />

​	Debug

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313214221129.png" alt="image-20230313214221129" style="zoom:33%;" />



结果3

​	Release

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313220615761.png" alt="image-20230313220615761" style="zoom:33%;" />

​	Debug

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313220728308.png" alt="image-20230313220728308" style="zoom:33%;" />



结果4

​	Release

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313214506633.png" alt="image-20230313214506633" style="zoom:33%;" />



​	Debug

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313214539454.png" alt="image-20230313214539454" style="zoom:33%;" />





linux下GDB：

结果1

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313212911653.png" alt="image-20230313212911653" style="zoom: 33%;" />



结果2

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313213633547.png" alt="image-20230313213633547" />



结果3

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313213341074.png" alt="image-20230313213341074" style="zoom:33%;" />



结果4

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313213633547.png" alt="image-20230313213633547" style="zoom:33%;" />





总结：在windows下，数组越界的位置值为ffffffxx来判断越界，负下标为随机的值(规律很诡异，-1为字符‘6’，-2为空)，但能给越界的位置赋值，Linux GDB会报warning，越界为0，负下标为0，但能赋值。



### 如何判断动态申请越界（C++ 方式，注意源程序后缀为.cpp）

VS2022 的 x86/Debug，Release 模式

结果1：

​	Release

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313225428196.png" alt="image-20230313225428196" style="zoom:33%;" />

​	Debug

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313225527755.png" alt="image-20230313225527755" style="zoom: 50%;" />



结果2

​	Release

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313225737585.png" alt="image-20230313225737585" style="zoom: 50%;" />

​	Debug

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313225802537.png" alt="image-20230313225802537" style="zoom: 50%;" />



结果3

​	Release

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313225845214.png" alt="image-20230313225845214" style="zoom: 50%;" />

​	Debug

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313230125172.png" alt="image-20230313230125172" style="zoom:50%;" />



结果4

​	Release

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313225959204.png" alt="image-20230313225959204" style="zoom:50%;" />

​	

​	Debug

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313230024667.png" alt="image-20230313230024667" style="zoom:50%;" />



linux下GDB：

结果1

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313230450742.png" alt="image-20230313230450742" style="zoom:50%;" />

结果2

![image-20230313230543858](C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313230543858.png)

结果3

![image-20230313230621685](C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313230621685.png)

结果4

![image-20230313230651161](C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230313230651161.png)



总结：结果似乎和c差不多，在windows下，数组越界的位置值为ffffffxx来判断越界，但能给越界的位置赋值，负下标的值随机(规律很诡异，-1为字符‘6’，-2为空)，Linux GDB会报warning，越界为0，但能赋值，负下标为0。



### 如何判断普通数组的越界访问（C++ 方式，注意源程序后缀为.cpp）

对于字符数组：

main函数

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230314102452816.png" alt="image-20230314102452816" style="zoom:33%;" />



Release:

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230314102207519.png" alt="image-20230314102207519" style="zoom:33%;" />

Debug:

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230314102536554.png" alt="image-20230314102536554" style="zoom:33%;" />

GDB:

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230314102757279.png" alt="image-20230314102757279" style="zoom:33%;" />



对于整形数组：

main函数

![image-20230314102909608](C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230314102909608.png)



Release：

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230314103011106.png" alt="image-20230314103011106" style="zoom:33%;" />

Debug：

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230314103036173.png" alt="image-20230314103036173" style="zoom:33%;" />

GDB：

<img src="C:\Users\16547\AppData\Roaming\Typora\typora-user-images\image-20230314103139789.png" alt="image-20230314103139789" style="zoom:33%;" />

总结：字符串数组在三种模式下结果相同，负下标为0，超出范围有一个a作为越界判断。数组在windows底下相同，且能给负下标以及超出范围的位置赋值，在linux底下无法给负下标赋值，也能给超出范围赋值。



**具体代码见：question6**



### 总结

​	在不同编译环境下，数组越界位置的值不太相同，且在动态申请空间和静态申请空间的时候也不太相同。Debug和Release模式大致相同，linux下的GDB与windows底下差别非常大。感觉在使用静态申请空间时，数组越界的影响会稍微小一点，在动态申请空间时影响巨大。在使用数组时得尽可能清晰地了解自己使用了多少空间，避免越界。